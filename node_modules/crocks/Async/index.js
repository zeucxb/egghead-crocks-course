/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var VERSION = 2

var _implements = require('../core/implements')
var _inspect = require('../core/inspect')
var type = require('../core/types').type('Async')
var _type = require('../core/types').typeFn(type(), VERSION)
var fl = require('../core/flNames')

var array = require('../core/array')
var compose = require('../core/compose')
var once = require('../core/once')
var unit = require('../core/_unit')

var isArray = require('../core/isArray')
var isFoldable = require('../core/isFoldable')
var isFunction = require('../core/isFunction')
var isPromise = require('../core/isPromise')
var isSameType = require('../core/isSameType')

var allAsyncs = function (xs) { return xs.reduce(function (acc, x) { return acc && isSameType(Async, x); }, true); }

var _of =
  function (x) { return Async(function (_, resolve) { return resolve(x); }); }

var Rejected =
  function (x) { return Async(function (reject) { return reject(x); }); }

function all(asyncs) {
  if(!(isFoldable(asyncs) && allAsyncs(asyncs))) {
    throw new TypeError('Async.all: Foldable structure of Asyncs required')
  }

  if(isArray(asyncs)) {
    return array.sequence(Async.of, asyncs)
  }

  return asyncs.sequence(Async.of)
}

function fromNode(fn, ctx) {
  if(!isFunction(fn)) {
    throw new TypeError('Async.fromNode: CPS function required')
  }

  return function () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      return Async(function (reject, resolve) {
      fn.apply(ctx,
        args.concat(
          function (err, data) { return err ? reject(err) : resolve(data); }
        )
      )
    });
  }
}

function fromPromise(fn) {
  if(!isFunction(fn)) {
    throw new TypeError('Async.fromPromise: Promise returning function required')
  }

  return function() {
    var promiseArgs = arguments

    return Async(function(reject, resolve) {
      var promise = fn.apply(null, promiseArgs)

      if(!isPromise(promise)) {
        throw new TypeError('Async.fromPromise: Promise returning function required')
      }

      promise
        .then(resolve)
        .catch(reject)
    })
  }
}

function Async(fn, parentCancel) {
  var obj;

  if(!isFunction(fn)) {
    throw new TypeError('Async: Function required')
  }

  var cancelled = false

  var cancel = compose(
    function () { cancelled = true },
    isFunction(parentCancel) ? parentCancel : unit
  )

  var of =
    _of

  var inspect =
    function () { return ("Async" + (_inspect(fn))); }

  function fork(reject, resolve, cleanup) {
    if(!isFunction(reject) || !isFunction(resolve)) {
      throw new TypeError('Async.fork: Reject and resolve functions required')
    }

    var forkCancel =
      isFunction(cleanup) ? cleanup : unit

    fn(
      function (x) { return cancelled ? unit() : reject(x); },
      function (x) { return cancelled ? unit() : resolve(x); }
    )

    return once(compose(forkCancel, cancel))
  }

  function toPromise() {
    return new Promise(function(resolve, reject) {
      fork(reject, resolve)
    })
  }

  function swap(l, r) {
    if(!isFunction(l) || !isFunction(r)) {
      throw new TypeError('Async.swap: Functions required for both arguments')
    }

    return Async(function(reject, resolve) {
      fork(
        compose(resolve, l),
        compose(reject, r)
      )
    }, cancel)
  }

  function coalesce(l, r) {
    if(!isFunction(l) || !isFunction(r)) {
      throw new TypeError('Async.coalesce: Functions required for both arguments')
    }

    return Async(function(reject, resolve) {
      fork(
        compose(resolve, l),
        compose(resolve, r)
      )
    }, cancel)
  }

  function map(method) {
    return function(mapFn) {
      if(!isFunction(mapFn)) {
        throw new TypeError(("Async." + method + ": Function required"))
      }

      return Async(function(reject, resolve) {
        fork(reject, compose(resolve, mapFn))
      }, cancel)
    }
  }

  function bimap(method) {
    return function(l, r) {
      if(!isFunction(l) || !isFunction(r)) {
        throw new TypeError(("Async." + method + ": Functions required for both arguments"))
      }

      return Async(function(reject, resolve) {
        fork(
          compose(reject, l),
          compose(resolve, r)
        )
      }, cancel)
    }
  }

  function alt(method) {
    return function(m) {
      var innerCancel = unit

      if(!isSameType(Async, m)) {
        throw new TypeError(("Async." + method + ": Async required"))
      }

      return Async(function (rej, res) {
        fork(
          function () { innerCancel = m.fork(rej, res) },
          res
        )
      }, once(function () { return innerCancel(cancel()); }))
    }
  }

  function ap(m) {
    var apFn = null
    var value = null
    var fnDone = false
    var valueDone = false
    var innerCancel = unit

    if(!isSameType(Async, m)) {
      throw new TypeError('Async.ap: Async required')
    }

    return Async(function(reject, resolve) {
      var rejectOnce = once(reject)

      function resolveBoth() {
        if(fnDone && valueDone) {
          compose(resolve, apFn)(value)
        }
      }

      fork(rejectOnce, function(f) {
        if(!isFunction(f)) {
          throw new TypeError('Async.ap: Wrapped value must be a function')
        }

        fnDone = true
        apFn = f
        resolveBoth()
      })

      innerCancel = m.fork(rejectOnce, function (x) {
        valueDone = true
        value = x
        resolveBoth()
      })
    }, once(function () { innerCancel(cancel()) }))
  }

  function chain(method) {
    return function(mapFn) {
      var innerCancel = unit

      if(!isFunction(mapFn)) {
        throw new TypeError(
          ("Async." + method + ": Async returning function required")
        )
      }

      return Async(function(reject, resolve) {
        fork(reject, function(x) {
          var m = mapFn(x)

          if(!isSameType(Async, m)) {
            throw new TypeError(
              ("Async." + method + ": Function must return another Async")
            )
          }

          innerCancel = m.fork(reject, resolve)
        })
      }, once(function () { innerCancel(cancel()) }))
    }
  }

  return ( obj = {
    fork: fork, toPromise: toPromise, inspect: inspect,
    toString: inspect, type: type,
    swap: swap, coalesce: coalesce, ap: ap, of: of,
    alt: alt('alt'),
    bimap: bimap('bimap'),
    map: map('map'),
    chain: chain('chain')
  }, obj[fl.of] = of, obj[fl.alt] = alt(fl.alt), obj[fl.bimap] = bimap(fl.bimap), obj[fl.map] = map(fl.map), obj[fl.chain] = chain(fl.chain), obj['@@type'] = _type, obj.constructor = Async, obj )
}

Async.of = _of
Async.type = type

Async[fl.of] = _of
Async['@@type'] = _type

Async.Rejected = Rejected
Async.Resolved = _of

Async.fromPromise = fromPromise
Async.fromNode = fromNode

Async.all = all

Async['@@implements'] = _implements(
  [ 'alt', 'ap', 'bimap', 'chain', 'map', 'of' ]
)

module.exports = Async
